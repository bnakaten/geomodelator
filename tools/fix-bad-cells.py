# License: GNU General Public License, Version 3, 29 June 2007
# Copyright Â© 2022 Helmholtz Centre Potsdam GFZ German Research Centre for
# Geosciences, Potsdam, Germany

#!/usr/bin/env python
# coding: utf-8

'''
    Fix bad partition cell clusters in GEOMODELATOR grid
'''
import os
import sys
import glob

import numpy as np
from numba import njit

# grid dimensions
MODELDIMENSION = [48550, 41420, 1050]

# number of cells in x, y, z direction
nx = int((MODELDIMENSION[0])/250)
ny = int((MODELDIMENSION[1])/250)
nz = int((MODELDIMENSION[2])/2)

# reorganize cell clusters with size of cs (integer) cells
cs = 6

def print_help():
    '''
        Help text
    '''
    text = '''
Call: \033[1mpython fix-bad_cells.py [OPTIONS] FILE\033[0m

This script removes cell partition groups (clusters) from a model generated by
GEOMODELATOR less then a defined cluster size. In some cases the fixing has to
be rerun iteratively to resolve all initial and newly developed bad clusters.
The script ends the number of fixed clusters do not change anymore. The output
is file equal to GEOMODELATOR numpy output.

Example

    python fix-bad-cells.py --cs=9 --config=config.py  model_partitions.npz 

FILE

    GEOMODELATOR numpy output \033[1mmodel partition file \033[0m should be
    numpy compressed format and the array name should be "data" or "array1".
    Additional the array "cell_ids" can be considered.

OPTIONS

    --cs=SIZE
        SIZE is an integer number for \033[1mcluster size\033[0m can be used to
        change the cell clusters that should be removed. Default cluster size
        is 6. All cell partition groups (clusters) that are less then the cluster
        size will be assigned to the biggest surrounding partition.

    --config=FILENAME
        FILENAME should be a GEOMODELATOR \033[1mmodel config file\033[0m which then
        will be used to set the model discretization and dimension. If no file is
        used initialize the model settings inside of this script by customizing
        MODELDIMENSION, nx, ny, nz.
'''
    print(text)
    sys.exit()

L = []
cid = []

# check mandatory input file
if len(sys.argv) < 2:
    print('\033[1mError: Input file missing!\033[0m')
    print_help()

for filename in sys.argv[1:]:
    if filename.split('=', maxsplit=1)[0] == '--config':
        # import GEOMODELATOR config.py
        cfile = os.path.basename(filename.split('=')[1]).split('.')[0]
        cdir = os.path.dirname(filename.split('=')[1])
        if os.path.dirname(filename.split('=')[1]) != "":
            cdir += "/"

        sys.path.insert(0, cdir)

        filenamelist = sorted(glob.glob(cdir + cfile + '.py'))
        if not filenamelist:
            print('\033[1mError: Config file does not exist!\033[0m')
            print_help()
            sys.exit(1)

        cfg = __import__(cfile)

        nx = cfg.nx
        ny = cfg.ny
        nz = cfg.nz
    elif filename.split('=', maxsplit=1)[0] == '--cs':
        cs = int(filename.split('=')[1])
    else:
        with np.load(filename) as data:
            # L = data['data'].astype(int)
            data_name = 'data'
            if data_name not in data:
                data_name  = 'array1'

            L = data[data_name].astype(int)
            unfixable = np.zeros_like(L)

            data_name = 'cellids'
            if data_name in data:
                cid = data['cellids'].astype(int)

        data_filename = filename

# cache array for cluster search
tcs = cs*2+1
T = np.zeros([tcs, tcs, tcs], dtype=np.int8)

print('\nFix bad cell partitions')
print(f'\nModel dimension (nx, ny, nz): {nx}, {ny}, {nz}, '+\
        f'total cell number: {nx*ny*nz}')
print(f'Independent cells (clusters) with less then {cs} will be removed.\n')

@njit
def reorganize_bad_partition_cells(L, T, cs):
    '''
        Reogranize bad parition cells 
    '''
    counter = 0
    unfixable = np.zeros_like(L)

    for k in range(nz-1, -1, -1):
        for j in range(ny):
            for i in range(nx):
                if L[k,j,i] != 0:
                    T[:,:,:] = 0
                    cc, T = find_cluster(L, i, j, k, T, cs, cs, cs, 1, cs)
                    if cc < cs:
                        hdpid = pid_with_highest_density(T)
                        L[k,j,i] = hdpid
                        unfixable[k,j,i] = 1
                        counter +=1
    return L, unfixable, counter


@njit
def pid_with_highest_density(T):
    '''
        find parition id with hightest density in bad cell neigboring
    '''
    T_flat = T.flatten()
    T_clean = np.delete(T_flat, np.where(T_flat == 0)[0])
    y = np.bincount(T_clean)
    ii = np.nonzero(y)[0]
    id_max = np.argmax(y[ii])
    return ii[id_max]


@njit
def find_cluster(L, i, j, k, T, l, m, n, cc, cs):
    '''
        find bad cells by searching recursive in the neigbhoring
    '''
    cpa = L[k,j,i]

    if cpa > 0 and cc <= cs:
        T[n,m,l] = cpa

        if 0 <= k-1 and T[n-1,m,l] == 0 and cc < cs:
            if L[k-1,j,i] == cpa and cc < cs:
                cc, T = find_cluster(L, i, j, k-1, T, l, m, n-1, cc+1, cs)
            elif L[k-1,j,i] != cpa and L[k-1,j,i] != 0:
                T[n-1,m,l] = L[k-1,j,i]

        if k+1 < L.shape[0] and T[n+1,m,l] == 0 and cc < cs:
            if L[k+1,j,i] == cpa and cc < cs:
                cc, T = find_cluster(L, i, j, k+1, T, l, m, n+1, cc+1, cs)
            elif L[k+1,j,i] != cpa and L[k+1,j,i] != 0:
                T[n+1,m,l] = L[k+1,j,i]

        if 0 <= j-1 and T[n,m-1,l] == 0 and cc < cs:
            if L[k,j-1,i] == cpa:
                cc, T = find_cluster(L, i, j-1, k, T, l, m-1, n, cc+1, cs)
            elif L[k,j-1,i] != cpa and L[k,j-1,i] != 0:
                T[n,m-1,l] = L[k,j-1,i]

        if j+1 < L.shape[1] and T[n,m+1,l] == 0 and cc < cs:
            if L[k,j+1,i] == cpa and cc < cs:
                cc, T = find_cluster(L, i, j+1, k, T, l, m+1, n, cc+1, cs)
            elif L[k,j+1,i] != cpa and L[k,j+1,i] != 0:
                T[n,m+1,l] = L[k,j+1,i]

        if 0 <= i-1 and T[n,m,l-1] == 0 and cc < cs:
            if L[k,j,i-1] == cpa and cc < cs:
                cc, T = find_cluster(L, i-1, j, k, T, l-1, m, n, cc+1, cs)
            elif L[k,j,i-1] != cpa and L[k,j,i-1] != 0:
                T[n,m,l-1] = L[k,j,i-1]

        if i+1 < L.shape[2] and T[n,m,l+1] == 0 and cc < cs:
            if L[k,j,i+1] == cpa and cc < cs:
                cc, T = find_cluster(L, i+1, j, k, T, l+1, m, n, cc+1, cs)
            elif L[k,j,i+1] != cpa and L[k,j,i+1] != 0:
                T[n,m,l+1] = L[k,j,i+1]

    return cc, T


loops = 1
file_note = f"_cs-{cs}_bc"
counter = 1

print("Reorganize cell partition ids:")
while counter > 0:
    counter_prev = counter

    print(f"\t{loops}. run ", end="")
    L, unfixable, counter = reorganize_bad_partition_cells(L, T, cs)

    loops += 1
    if counter_prev == counter:
        print(f"""\t{counter} bad cells are unfixable. Maybe adjust the cluster size or the
\t\twhole model in GEOMODELATOR. The visualization of bad cells can be done
\t\tin Paraview by using the script grid2vtk.py.""")
        break

    print(f"\t{counter} bad cells fixed")

    file_note += f"-{counter}"

new_filename = os.path.basename(data_filename).split(".")[0] + file_note + '.npz'
np.savez_compressed(new_filename , data=L, cell_ids=cid, unfixable=unfixable)

print(f"\nOutput file: {new_filename}")
